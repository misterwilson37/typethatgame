<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>TypeThatBook: Wizard of Oz</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

    <div id="hud">
        <div id="user-info">Guest</div>
        <div>Active Time: <span id="timer-display">00:00</span></div>
        <div>WPM: <span id="wpm-display">0</span> | Acc: <span id="acc-display">100%</span></div>
    </div>

    <div id="game-container">
        <div id="text-stream">Loading book...</div>
        <div id="image-panel"><img id="story-img" src="" alt="Story illustration"></div>
    </div>

    <div id="virtual-keyboard">
        </div>

    <div id="modal" class="modal">
        <div class="modal-content">
            <h1 id="modal-title">Welcome to Oz</h1>
            <p id="modal-body">Type the story. Accuracy matters more than speed.</p>
            <button id="action-btn" style="padding: 10px 20px; font-size: 18px; cursor: pointer;">Start Chapter 1</button>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { getFirestore, doc, getDoc, updateDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";

        // --- PASTE YOUR CONFIG HERE ---
        const firebaseConfig = {
            apiKey: "AIzaSyCV3RVWUwTLKoi_ze-FNCiam4lhggHKHR8",
            authDomain: "typethatbook.firebaseapp.com",
            projectId: "typethatbook",
            storageBucket: "typethatbook.firebasestorage.app",
            messagingSenderId: "213085805139",
            appId: "1:213085805139:web:b7ffdc2b2eab12344a04a6"
        };
        // -----------------------------

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // STATE
        let currentUser = null;
        let bookData = null;
        let currentSegmentIndex = 0;
        let fullText = "";
        let currentCharIndex = 0;
        let mistakes = 0;
        let startTime = null;
        let activeSeconds = 0;
        let lastActivityTime = 0;
        let timerInterval = null;
        let isGameActive = false;
        
        // DOM ELEMENTS
        const textStream = document.getElementById('text-stream');
        const keyboardDiv = document.getElementById('virtual-keyboard');
        const storyImg = document.getElementById('story-img');
        const imgPanel = document.getElementById('image-panel');

        // --- INIT ---
        async function init() {
            createKeyboard();
            
            // Auto-login anonymously for now (easier for kids initially)
            // You can switch to Google Auth later
            signInAnonymously(auth).catch(console.error);

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    currentUser = user;
                    document.getElementById('user-info').innerText = "Student ID: " + user.uid.slice(0,5);
                    await loadChapter(1);
                }
            });
        }

        // --- LOAD DATA ---
        async function loadChapter(chapterNum) {
            const docRef = doc(db, "books", "wizard_of_oz", "chapters", "chapter_" + chapterNum);
            const docSnap = await getDoc(docRef);

            if (docSnap.exists()) {
                bookData = docSnap.data();
                setupGame();
            } else {
                console.error("No such chapter! Did you run the Seeder?");
                textStream.innerHTML = "Error: Chapter not found. Run seeder.html first.";
            }
        }

        function setupGame() {
            // Combine all segments into one long string for simpler typing logic
            // But we keep track of where segments start to show images
            fullText = bookData.segments.map(s => s.text).join(" ");
            
            // Normalize text (replace fancy quotes)
            fullText = fullText.replace(/[\u2018\u2019]/g, "'").replace(/[\u201C\u201D]/g, '"');

            renderText();
            document.getElementById('modal').classList.remove('hidden');
            document.getElementById('action-btn').onclick = startGame;
        }

        function renderText() {
            textStream.innerHTML = '';
            // Split into words to handle wrapping
            const words = fullText.split(' ');
            let charCount = 0;

            words.forEach(word => {
                const wordSpan = document.createElement('span');
                wordSpan.className = 'word';
                
                for (let char of word) {
                    const span = document.createElement('span');
                    span.className = 'letter';
                    span.innerText = char;
                    span.dataset.index = charCount;
                    wordSpan.appendChild(span);
                    charCount++;
                }

                // Add space
                const spaceSpan = document.createElement('span');
                spaceSpan.className = 'letter';
                spaceSpan.innerHTML = '&nbsp;';
                spaceSpan.dataset.index = charCount;
                wordSpan.appendChild(spaceSpan);
                charCount++;

                textStream.appendChild(wordSpan);
            });
        }

        // --- GAME LOOP ---
        function startGame() {
            document.getElementById('modal').classList.add('hidden');
            isGameActive = true;
            startTime = Date.now();
            lastActivityTime = Date.now();
            focusOnCurrentChar();
            
            // Start the "Active Time" ticker
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(gameTick, 1000); // Check every second
        }

        function gameTick() {
            if (!isGameActive) return;

            // 3 Second Rule
            if (Date.now() - lastActivityTime <= 3000) {
                activeSeconds++;
                // Update HUD
                const mins = Math.floor(activeSeconds / 60).toString().padStart(2, '0');
                const secs = (activeSeconds % 60).toString().padStart(2, '0');
                document.getElementById('timer-display').innerText = `${mins}:${secs}`;
                
                // Save progress periodically (every 10s to save writes)
                if (activeSeconds % 10 === 0) saveProgress();
            }

            // Calculate WPM
            const timeMins = (Date.now() - startTime) / 60000;
            const wpm = Math.round((currentCharIndex / 5) / timeMins) || 0;
            document.getElementById('wpm-display').innerText = wpm;
        }

        // --- TYPING LOGIC ---
        document.addEventListener('keydown', (e) => {
            if (!isGameActive) return;
            
            // Ignore shift, ctrl, etc.
            if (e.key.length > 1 && e.key !== "Backspace") return;

            // Prevent default scrolling (Spacebar)
            if(e.key === " ") e.preventDefault();

            const targetChar = fullText[currentCharIndex];
            const letterEls = document.querySelectorAll('.letter');
            const currentEl = letterEls[currentCharIndex];

            // HEARTBEAT: Update last activity time
            lastActivityTime = Date.now();

            if (e.key === targetChar) {
                // CORRECT
                currentEl.classList.add('correct');
                currentEl.classList.remove('active');
                currentCharIndex++;
                
                // End of Chapter?
                if (currentCharIndex >= fullText.length) {
                    finishChapter();
                    return;
                }

                letterEls[currentCharIndex].classList.add('active');
                updateAccuracy();
                checkForImageUpdate();
                highlightKey(fullText[currentCharIndex]); // Highlight NEXT key
                centerView();

            } else {
                // MISTAKE
                mistakes++;
                currentEl.classList.add('incorrect');
                
                // Visual feedback on keyboard
                flashKey(e.key.toUpperCase(), 'red');
                updateAccuracy();
            }
        });

        function centerView() {
            const currentEl = document.querySelectorAll('.letter')[currentCharIndex];
            if (!currentEl) return;

            // We calculate where the current letter is relative to the container
            // and shift the container UP to keep that letter in the vertical center
            const containerCenter = document.getElementById('game-container').offsetHeight / 2;
            const letterTop = currentEl.offsetTop;
            
            // Offset logic
            textStream.style.transform = `translateY(${containerCenter - letterTop - 20}px)`;
        }

        function checkForImageUpdate() {
            // Find which segment we are in based on character count
            // This is a simplified lookup. 
            // In a robust app, we'd map char ranges to segment IDs.
            // For now, let's just rotate images based on progress % for demo purposes
            // (Since mapping exact characters to segments requires complex indexing)
            
            const progress = currentCharIndex / fullText.length;
            const segmentIndex = Math.floor(progress * bookData.segments.length);
            
            const segment = bookData.segments[segmentIndex];
            if (segment && segment.image) {
                storyImg.src = segment.image;
                imgPanel.style.display = 'block';
            } else {
                imgPanel.style.display = 'none';
            }
        }

        function updateAccuracy() {
            const total = currentCharIndex + mistakes;
            const acc = total === 0 ? 100 : Math.round((currentCharIndex / total) * 100);
            document.getElementById('acc-display').innerText = acc + "%";
        }

        function finishChapter() {
            isGameActive = false;
            clearInterval(timerInterval);
            saveProgress();
            
            document.getElementById('modal-title').innerText = "Chapter Complete!";
            document.getElementById('modal-body').innerText = `Great job! You were active for ${activeSeconds} seconds.`;
            document.getElementById('action-btn').innerText = "Play Again";
            document.getElementById('action-btn').onclick = () => location.reload();
            document.getElementById('modal').classList.remove('hidden');
        }

        async function saveProgress() {
            if (!currentUser) return;
            const userRef = doc(db, "users", currentUser.uid);
            
            await setDoc(userRef, {
                activeSeconds: activeSeconds, // This will overwrite; in real app use 'increment'
                lastChapter: 1,
                lastUpdated: new Date()
            }, { merge: true });
        }

        // --- VISUAL KEYBOARD ---
        function createKeyboard() {
            const rows = [
                "QWERTYUIOP",
                "ASDFGHJKL",
                "ZXCVBNM"
            ];
            
            rows.forEach(rowStr => {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'kb-row';
                for (let char of rowStr) {
                    const k = document.createElement('div');
                    k.className = 'key';
                    k.id = 'key-' + char;
                    k.innerText = char;
                    rowDiv.appendChild(k);
                }
                keyboardDiv.appendChild(rowDiv);
            });
            // Spacebar
            const spaceRow = document.createElement('div');
            spaceRow.className = 'kb-row';
            const space = document.createElement('div');
            space.className = 'key space';
            space.id = 'key-SPACE';
            space.innerText = "SPACE";
            spaceRow.appendChild(space);
            keyboardDiv.appendChild(spaceRow);
        }

        function highlightKey(char) {
            // Reset all
            document.querySelectorAll('.key').forEach(k => k.classList.remove('target'));
            
            let keyId = 'key-' + char.toUpperCase();
            if (char === ' ') keyId = 'key-SPACE';
            
            const el = document.getElementById(keyId);
            if (el) el.classList.add('target');
        }

        function flashKey(char, color) {
            let keyId = 'key-' + char.toUpperCase();
            if (char === ' ') keyId = 'key-SPACE';
            const el = document.getElementById(keyId);
            if (el) {
                el.style.backgroundColor = color;
                setTimeout(() => el.style.backgroundColor = '', 200);
            }
        }

        function focusOnCurrentChar() {
            const firstChar = fullText[currentCharIndex] || ' ';
            highlightKey(firstChar);
        }

        init();
    </script>
</body>
</html>
